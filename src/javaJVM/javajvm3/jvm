现在与未来
随着时代的变迁 JVM的实现多种多样 而我们还要从最初的虚拟机说起

虚拟机的发展历程
在1996 Java1.0面世时 第一款商用虚拟机Sun Classic VM开始了它的使命 这款虚拟机提供了一个Java解释器 也就是将我们的class文件进行读取 最后像上面一样得到一条一条的命令
JVM再将指令依次执行 虽然这样的运行方式非常的简单易懂 但是它的效率实际上是很低的 就像你耳机里一边在放六级听力
你必须同时记在脑海里面然后等着问问题再去选择问题的答案一样 更重要的是同样的代码每次都需要重新翻译再执行

这个时候我们就需要更加高效的方式来运行Java程序 随着后面的发展 现在大多数的主流的JVM都包含即时编译器 JVM会根据当前代码的进行判断 当虚拟机发现某个方法或代码块的运行特别频繁时
就会把这些代码认定为"热点代码" 为了提高热点代码的执行效率 在运行时 虚拟机将会把这些代码编译成与本地平台相关的机器码 并进行各种层次的优化完成这个任务的编译器称为即时编译器(Just In Time Compiler)

                                        .java(源代码)
                                             |
                                             |
                                        .class(字节码)
                                             |
                                             |
                                          类加载器
                                             |
                                             |
                                         字节码校验器
                                         |        |
                                         |        |
                                      解释器    jit编译器
                                        |         |
                                        |         |
                                        ----硬件----

在JDK1.4时 Sun Classic VM完全退出了历史舞台 取而代之的是至今都在使用的HotSpot VM 它是目前使用最广泛的虚拟机 拥有上面所说的热点代码探测技术
准确式内存管理(虚拟机可以知道内存中某个位置的数据具体是什么类型)等技术 而我们之后的章节都是基于HotSpot虚拟机进行讲解

虚拟机发展的未来
2018年4月 Oracle Labs公开了最新的GraalVM 它是一种全新的虚拟机 它能够实现所有的语言统一运行在虚拟机中

Graal VM被官方称为"Universal VM"和"Polyglot VM" 这是一个在HotSpot虚拟机基础上增强而成的跨语言全栈虚拟机 可以作为"任何语言"的运行平台使
这里"任何语言"包括了Java Scala Groovy Kotlin等基于Java虚拟机之上的语言 还包括了C C++ Rust等基于LLVM的语言 同时支持其他像JavaScript Ruby Python和R语言等等
Graal VM可以无额外开销地混合使用这些编程语言 支持不同语言中混用对方的接口和对象 也能够支持这些语言使用已经编写好的本地库文件

Graal VM的基本工作原理是将这些语言的源代码(例如JavaScript)或源代码编译后的中间格式(例如LLVM字节码)通过解释器转换为能被Graal VM接受的中间表示(Intermediate Representation IR)
譬如设计一个解释器专门对LLVM输出的字节码进行转换来支持C和C++语言 这个过程称为"程序特化"(Specialized 也常称为Partial Evaluation)
Graal VM提供了Truffle工具集来快速构建面向一种新语言的解释器 并用它构建了一个称为Sulong的高性能LLVM字节码解释器

目前最新的SpringBoot已经提供了本地运行方案: https://docs.spring.io/spring-native/docs/current/reference/htmlsingle/

    Spring Native支持使用GraalVM原生镜像编译器将Spring应用程序编译为本机可执行文件
    与Java虚拟机相比 原生映像可以为许多类型的工作负载实现更简单 更加持续的托管 包括微服务 非常适合容器的功能工作负载和Kubernetes
    使用本机映像提供了关键优势 如即时启动 即时峰值性能和减少内存消耗
    GraalVM原生项目预计随着时间的推移会改进一些缺点和权衡 构建本机映像是一个比常规应用程序慢的繁重过程 热身后的本机映像运行时优化较少 最后 它不如JVM成熟 行为各不相同
    常规JVM和此原生映像平台的主要区别是:
        > 从主入口点对应用程序进行静态分析 在构建时进行
        > 未使用的部件将在构建时删除
        > 反射 资源和动态代理需要配置
        > Classpath在构建时是固定的
        > 没有类惰性加载: 可执行文件中运送的所有内容将在启动时加载到内存中
        > 一些代码将在构建时运行
        > ava应用程序的某些方面有一些不受完全支持的限制
    该项目的目标是孵化对Spring Native的支持 Spring Native是Spring JVM的替代品 并提供旨在打包在轻量级容器中的原生部署选项 在实践中 目标是在这个新平台上支持您的Spring应用程序 几乎未经修改

优点:
    1. 立即启动 一般启动时间小于100ms
    2. 更低的内存消耗
    3. 独立部署 不再需要JVM
    4. 同样的峰值性能要比JVM消耗的内存小

缺点:
    1. 构建时间长
    2. 只支持新的Springboot版本(2.4.4+)